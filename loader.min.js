/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

Array.prototype.gemEachCons = function (num) {
  return Array.from(
    { length: this.length - num + 1 }, 
    (_, i) => this.slice(i, i + num)
  )
}

Array.prototype.gemCombination = function (num) {	
	if (num > this.length || num <= 0) { return [] }
	if (num == this.length) { return [this] }
	
	if (num == 1) {
    let combos = []
    
		for (let i = 0; i < this.length; i++) {
			combos.push([this[i]])
    }
    
		return combos
	}

  let combos = []
  
	for (let i = 0; i < this.length - num + 1; i++) {
		let head = this.slice(i, i + 1);
		let tailCombos = this.slice(i + 1).gemCombination(num - 1)

		for (let j = 0; j < tailCombos.length; j++) {
			combos.push(head.concat(tailCombos[j]))
		}
  }
  
	return combos
}

Array.prototype.gemUniq = function () {
  return [...new Set(this)]
}

/***/ }),
/* 1 */
/***/ (function(module, exports) {

Number.prototype.gemPad = function(size) {
  var nbTos = String(this)
  while (nbTos.length < size) { nbTos = "0" + nbTos }
  return nbTos
}

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./fr.js
let data = {
    "combos": 
      {
        "HighCard": "Hauteur",
        "Pair": "Paire",
        "TwoPairs": "Deux paires",
        "ThreeOfAKind": "Brelan",
        "Straight": "Suite",
        "Flush": "Flush",
        "FullHouse": "Full",
        "FourOfAKind": "CarrÃ©",
        "StraightFlush": "Quinte Flush",
        "RoyalFlush": "Quinte Flush Royale"
      }
   }

/* harmony default export */ var fr = (data);
// EXTERNAL MODULE: ./lib/gem/src/gemArray.js
var gemArray = __webpack_require__(0);

// EXTERNAL MODULE: ./lib/gem/src/gemNumber.js
var gemNumber = __webpack_require__(1);

// CONCATENATED MODULE: ./src/Card.js
const VALUES = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"]
const VALUE_LABELS = 
  ["two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "jack", "queen", "king", "ace"]
const TYPES = ["d", "c", "h", "s"]
const FULL_TYPES = ["diamond", "club", "heart", "spade"]

class Card {
  static values() {
    return VALUES
  }

  static valueLabels() {
    return VALUE_LABELS
  }

  static types() {
    return TYPES
  }

  static fullTypes() {
    return FULL_TYPES
  }

  static ordered(cards) {
    return cards.sort((x, y) => y.score() - x.score())
  }

  constructor(label) {
    this.label = label
  }

  value() {
    return this.label.split('').slice(0, this.label.length - 1).join('')
  }

  valueLabel() {
    return Card.valueLabels()[Card.values().indexOf(this.value())]
  }

  valueCard() {
    if(Card.values().indexOf(this.value()) > 8) {
      return this.valueLabel()
    } else {
      return this.value()
    }
  }

  type() {
    return this.label.split('')[this.label.length-1]
  }

  fullType() {
    let i = Card.types().indexOf(this.type())

    return Card.fullTypes()[i]
  }

  score() {
    return parseInt(`${this.valueScore()}${this.typeScore()}`)
  }

  valueScore() {
    return Card.values().indexOf(this.value()) + 2
  }

  valueScoreString() {
    return this.valueScore().gemPad(2)
  }

  typeScore() {
    return Card.types().indexOf(this.type()) + 1
  }
}
/* harmony default export */ var src_Card = (Card);


// CONCATENATED MODULE: ./src/Deck.js


class Deck_Deck {
  constructor() {
    this._cards = src_Card.values().map(
      v => src_Card.types().map(
        t => new src_Card(v + t)
      )
    ).flat()
  }

  get cards() {
    return this._cards
  }

  shuffle() {
    let newCards = [];

    while(this._cards.length > 0) {
      let i = Math.floor(Math.random() * this._cards.length)
  
      newCards.push(this._cards[i])
      this._cards.splice(i, 1)
    }

    this._cards = newCards
  }
}
/* harmony default export */ var src_Deck = (Deck_Deck);

// CONCATENATED MODULE: ./src/Combo.js




class Combo_Combo {
  static factory(cards, combos) {
    cards = src_Card.ordered(cards)
    
    let classes = combos.map(c => c.class)
    let classNames = combos.map(c => c.name)

    return new (Combo_Combo.find(cards, classes))(cards, classNames)
  }

  static toCombos(cards, combos) {
    if(cards.length <= 5) { return Combo_Combo.factory(cards, combos) }

    let allCombos = cards.gemCombination(5).map(cds => Combo_Combo.factory(cds, combos))

    return allCombos
  }

  static best(combos) {
    return Combo_Combo.ordered(combos)[combos.length - 1]
  }

  static ordered(combos) {
    let oCombos = combos.sort((ca, cb) => Combo_Combo.compareScore(ca.score(), cb.score()))

    return oCombos
  }

  static compareScore(scoreA, scoreB) {
    if(scoreA[0] == scoreB[0]) {
      if(scoreA[1] == scoreB[1]) {
        return 0
      } else {
        return scoreA[1] > scoreB[1] ? 1 : -1
      }
    } else {
      return scoreA[0] > scoreB[0] ? 1 : -1
    }
  }

  static find(cards, classes) {
    return classes.find(klass => klass.isAvailable(cards))
  }

  static occureds(cards) {
    let cardsKeys = {}

    cards
      .forEach(card => {
        let label = card.valueLabel() + "s"

        if(cardsKeys[label]) {
          cardsKeys[label].push(card)
        } else {
          cardsKeys[label] = [card]
        }
      })

    return cardsKeys
  }

  constructor(cards, classNames) {
    this.list = classNames.reverse()
    this.cards = src_Card.ordered(cards)
  }

  score() {
    return [this.typeScore(), this.evenScore()]
  }

  typeScore() {
    return this.list.indexOf(this.constructor.name) + 1
  }

  evenScore() {
    let orderedValues = 
      [4,3,2,1].map(nb => this.whereValueOccures(nb)).flat()

    return parseInt(orderedValues.map(card => card.valueScoreString()).gemUniq().join(''))
  }

  whereValueOccures(nb) {
    let cards = Combo_Combo.occureds(this.cards)

    let values = 
      Object
        .keys(cards)
        .map(k => cards[k].length == nb ? cards[k] : null)
        .flat()
        .filter(Boolean)

    return src_Card.ordered(values)
  }

  name() {
    console.log(this.constructor.name)
    return fr.combos[this.constructor.name]
  }
}

// CONCATENATED MODULE: ./src/combos/HighCard.js

class HighCard_HighCard extends Combo_Combo {
  static isAvailable(cards) {
    return true
  }
}
/* harmony default export */ var combos_HighCard = (HighCard_HighCard);
// CONCATENATED MODULE: ./src/combos/Pair.js

class Pair_Pair extends Combo_Combo {
  static isAvailable(cards) {
    let occureds = Combo_Combo.occureds(cards)
    let nbVals = Object.values(occureds).map(o => o.length)

    return nbVals.includes(2)
  }
}
/* harmony default export */ var combos_Pair = (Pair_Pair);
// CONCATENATED MODULE: ./src/combos/TwoPairs.js

class TwoPairs_TwoPairs extends Combo_Combo {
  static isAvailable(cards) {
    let occureds = Combo_Combo.occureds(cards)
    let nbVals = Object.values(occureds).map(o => o.length)

    return nbVals.includes(2) && (nbVals.indexOf(2) !== nbVals.lastIndexOf(2))
  } 
}
/* harmony default export */ var combos_TwoPairs = (TwoPairs_TwoPairs);
// CONCATENATED MODULE: ./src/combos/ThreeOfAKind.js

class ThreeOfAKind_ThreeOfAKind extends Combo_Combo {
  static isAvailable(cards) {
    let occureds = Combo_Combo.occureds(cards)
    let nbVals = Object.values(occureds).map(o => o.length)

    return nbVals.includes(3)
  }
}
/* harmony default export */ var combos_ThreeOfAKind = (ThreeOfAKind_ThreeOfAKind);
// CONCATENATED MODULE: ./src/combos/Straight.js


class Straight_Straight extends Combo_Combo {
  static isAvailable(cards) {
    let values = cards.map(card => card.value())
    let found = 
      Straight_Straight.all().find(straight => JSON.stringify(values) === JSON.stringify(straight))

    return !!found
  }

  static all() {
    let straights = [['A', '5', '4', '3', '2']]

    src_Card.values().gemEachCons(5).forEach(straight => {
      straights.push(straight.reverse())
    })

    return straights
  }

}
/* harmony default export */ var combos_Straight = (Straight_Straight);
// CONCATENATED MODULE: ./src/combos/Flush.js

class Flush_Flush extends Combo_Combo {
  static isAvailable(cards) {
    let types = cards.map(card => card.type()).gemUniq()

    return types.length === 1
  }
}
/* harmony default export */ var combos_Flush = (Flush_Flush);
// CONCATENATED MODULE: ./src/combos/FullHouse.js

class FullHouse_FullHouse extends Combo_Combo {
  static isAvailable(cards) {
    let occureds = Combo_Combo.occureds(cards)
    let nbVals = Object.values(occureds).map(o => o.length)

    return nbVals.includes(3) && nbVals.includes(2)
  }
}
/* harmony default export */ var combos_FullHouse = (FullHouse_FullHouse);
// CONCATENATED MODULE: ./src/combos/FourOfAKind.js

class FourOfAKind_FourOfAKind extends Combo_Combo {
  static isAvailable(cards) {
    let occureds = Combo_Combo.occureds(cards)

    return Object.values(occureds).map(o => o.length).includes(4)
  }
}
/* harmony default export */ var combos_FourOfAKind = (FourOfAKind_FourOfAKind);
// CONCATENATED MODULE: ./src/combos/StraightFlush.js




class StraightFlush_StraightFlush extends Combo_Combo {
  static isAvailable(cards) {
    return combos_Straight.isAvailable(cards) && combos_Flush.isAvailable(cards)
  }
}
/* harmony default export */ var combos_StraightFlush = (StraightFlush_StraightFlush);
// CONCATENATED MODULE: ./src/combos/RoyalFlush.js

class RoyalFlush_RoyalFlush extends Combo_Combo {
  static isAvailable(cards) {
    let values = cards.map(card => card.value())
    let types = cards.map(card => card.type()).gemUniq()

    return (JSON.stringify(values) === JSON.stringify(["A", "K", "Q", "J", "10"])) && (types.length === 1)
  }
}
/* harmony default export */ var combos_RoyalFlush = (RoyalFlush_RoyalFlush);
// CONCATENATED MODULE: ./src/GameOfChips.js













const COMBOS = [
  {name: "RoyalFlush", class:combos_RoyalFlush },
  {name: "StraightFlush", class: combos_StraightFlush},
  {name: "FourOfAKind", class: combos_FourOfAKind},
  {name: "FullHouse", class: combos_FullHouse},
  {name: "Flush", class: combos_Flush},
  {name: "Straight", class: combos_Straight},
  {name: "ThreeOfAKind", class: combos_ThreeOfAKind},
  {name: "TwoPairs", class: combos_TwoPairs},
  {name: "Pair", class: combos_Pair},
  {name: "HighCard", class: combos_HighCard}
]

const HEROES = ['arya', 'jon', 'tyrion', 'daenerys']
const VILLAINS = ['jack', 'daenerys-on-tilt', 'cersei']

let heroIndex = 0
let villainIndex = 0

let avatarHero = document.getElementById("hero")
let avatarVillain = document.getElementById("villain") 

let imgHero = document.createElement('img')
imgHero.src = `./assets/images/players/${HEROES[heroIndex]}.png`

avatarHero.append(imgHero)

let imgVillain = document.createElement('img')
imgVillain.src = `./assets/images/players/${VILLAINS[villainIndex]}.png`

avatarVillain.append(imgVillain)

let heroHand, villainHand, flop, turn, river


document.getElementById("deal").addEventListener('click', () => {
  let deal = document.getElementById("deal")
  let deck = new src_Deck()
  deck.shuffle();

  let playerOneCombo = 
    Combo_Combo.best(
      Combo_Combo.toCombos(
        [
          deck.cards[0], deck.cards[1], deck.cards[4], 
          deck.cards[5], deck.cards[6], deck.cards[7], 
          deck.cards[8]
        ], COMBOS
      )
    )

  let playerTwoCombo = 
    Combo_Combo.best(
      Combo_Combo.toCombos(
        [
          deck.cards[2], deck.cards[3], deck.cards[4], 
          deck.cards[5], deck.cards[6], deck.cards[7], 
          deck.cards[8]
        ], COMBOS
      )
    )

  let heroMessage = document.getElementById("hero-message");
  let villainMessage = document.getElementById("villain-message");
  let win = document.getElementById("win");
  let loose = document.getElementById("loose");

  heroMessage.innerText = playerOneCombo.name();
  villainMessage.innerText = playerTwoCombo.name();
  
  let victory = Combo_Combo.compareScore(playerOneCombo.score(), playerTwoCombo.score())
  let highlightCards 

  if (victory == 0) {
    heroMessage.className = 'combo';
    villainMessage.className = 'combo';
    win.className = 'button hide is-success';
    loose.className = 'button hide is-danger';
    highlightCards = [playerOneCombo.cards, playerTwoCombo.cards].flat().gemUniq()
  } else if (victory == 1) {
    heroMessage.className = 'combo combo-win';
    villainMessage.className = 'combo combo-loose';
    win.className = 'button is-success';
    loose.className = 'button hide is-danger';
    highlightCards = playerOneCombo.cards
  } else {
    heroMessage.className = 'combo combo-loose';
    villainMessage.className = 'combo combo-win';
    win.className = 'button hide is-success';
    loose.className = 'button is-danger';
    highlightCards = playerTwoCombo.cards
  }

  ['player-1', 'player-2', 'player-3', 'player-4', 'flop-1', 'flop-2', 'flop-3', 'turn', 'river'].forEach(
    function(name, i) {
      let p = document.getElementById(name);
      p.className = "card bg-white"

      let img = document.createElement('img');
      let card = deck.cards[i];

      if(highlightCards.includes(card)) {
        p.className = "card bg-white focus"
      }

      img.src = `assets/images/cards/${card.valueCard()}_of_${card.fullType()}s.png`;
  
      deal.innerText = "Rejouer"
      p.textContent = "";
      p.append(img);
  })
})

// CONCATENATED MODULE: ./loader.js























/***/ })
/******/ ]);